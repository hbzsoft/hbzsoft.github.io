<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
	    tex2jax: {
	        inlineMath: [['$','$'], ['\(','\)']],
	        processEscapes: true
	    }
	});
    </script>
</head><h1>[CTSC2017] 密钥</h1>
<h2>题目描述</h2>
<p>一个密钥是一个长度为 n = 2k + 1 的字符串，它包含 1 个字母 X、k 个字母 A 和k 个字母 B。例如 k = 3 时，BAXABAB 就是一个密钥。</p>
<p>如下图所示，可以按顺时针顺序把这 2k+1 个字母排成一个圈：</p>
<p><img alt="" src="https://cdn.luogu.com.cn/upload/pic/5481.png" /> </p>
<p>在 k 个字母 A 中，有一部分可以定义为 “强的’’。具体来说，从 X 出发顺时针走到某个 A 时，如果途中 A 的数目<strong>严格多于</strong>B的数目，则称此字母 A 为强的。</p>
<p>对于上面的例子来说，顺时针方向从字母 X 数起第 1 个和第 2 个字母 A 是强的，而第 3 个字母 A 不是强的。</p>
<p>一个密钥的<strong>特征值</strong>就是其中包含的强的字母 A 的个数。</p>
<p>天才小朋友 KT 给出了一个结论：</p>
<p>假设 k 个字母 A 所在的位置已经固定，但是剩下的 k 个 B 和 1 个 X 的位置是未知的。（注意，满足这样要求的密钥一共有 k + 1 个，因为字母 X 还剩下 k + 1 个可能的位置。）</p>
<p>可以证明：所有这 k + 1 个可能的密钥的特征值是各不相同的，它们恰好为0, 1, 2, …, k。</p>
<p>下面的图是一个具体的示例，从左到右的四个子图中分别有 3 个，2 个，1 个，0个字母 A 是强的。</p>
<p><img alt="" src="https://cdn.luogu.com.cn/upload/pic/5482.png" /> </p>
<p>类似地，如果固定 k 个字母 B 的位置，那满足条件的所有 k + 1 个密钥的特征值也各不相同，恰好为 0, 1, …, k。</p>
<p>现在你需要解决以下三个问题：</p>
<ol>
<li>
<p>给定密钥中所有 A 的位置，当密钥的特征值为 0 时，请问 X 在哪个位置。</p>
</li>
<li>
<p>给定密钥中所有 A 的位置，当密钥的特征值为 S 时，请问 X 在哪个位置。</p>
</li>
<li>
<p>给定密钥中所有 B 的位置，当密钥的特征值为 S 时，请问 X 在哪个位置。</p>
</li>
</ol>
<p>注意：字符串的 2k + 1 个字母的位置由 1 到 2k + 1 编号。</p>
<p>【例子 1】</p>
<p>假定 k = 3, S = 2。那么：</p>
<p>当 A 的位置是 {2,4,6} 且特征值为 0 时，X 的位置在 7；</p>
<p>当 A 的位置是 {2,4,6} 且特征值为 2 时，X 的位置在 3；</p>
<p>当 B 的位置是 {2,4,6} 且特征值为 2 时，X 的位置在 5。</p>
<p>【例子 2】</p>
<p>假定 k=9。S=7。那么：</p>
<p>当 A 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 0 时，X 的位置在 14；</p>
<p>当 A 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 7 时，X 的位置在 18；</p>
<p>当 B 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 7 时，X 的位置在 17。</p>
<h2>输入输出格式</h2>
<h4>输入格式</h4>
<p>只包含一组测试数据。</p>
<p>第一行包含一个整数 k，意义如题所述。</p>
<p>第二行包含一个整数 seed，这个数将用于生成一个 k 元集合 P。</p>
<p>第三行包含一个整数 S，意义如题所述。</p>
<p>保证 0 ≤ S ≤ k ≤ 107。1 ≤ seed ≤ 10000。</p>
<p>在 cipher/下，包含两个用于生成输入数据的文件 cipher.cpp/pas。其中读入部分已经完成，在数组 p[] 中，若 p[i] = 0，表示 i 不属于集合 P，否则，i 属于集合P。</p>
<p><a href="http://pan.baidu.com/s/1i55NdWx">百度网盘链接&gt;&gt;   密码：9vr3</a> 请自行编译</p>
<p>```cpp</p>
<h1>include &lt;stdio.h&gt;</h1>
<h1>include &lt;string.h&gt;</h1>
<p>int p[20000005];
int seed, n, k, S;
int getrand() {
    seed = ((seed * 12321) ^ 9999) % 32768;
    return seed;
}
void generateData() {
    scanf( "%d%d%d", &amp;k, &amp;seed, &amp;S );
    int t = 0;
    n = k * 2 + 1;
    memset(p, 0, sizeof(p));
    for( int i = 1; i &lt;= n; ++i ) {
        p[i] = (getrand() / 128) % 2;
        t += p[i];
    }
    int i = 1;
    while( t &gt; k ) {
        while ( p[i] == 0 ) ++i;
        p[i] = 0;
        --t;
    }
    while( t &lt; k ) {
        while( p[i] == 1 ) ++i;
        p[i] = 1;
        ++t;
    }
}
int main() {
    generateData();
    return 0;
}
```</p>
<h4>输出格式</h4>
<p>输出三行，每行一个数，依次对应问题描述中的三个子问题的答案。</p>
<p>即：
1. 第一个数表示当 k 元集合 P 代表 A 的位置且特征值为 0 时 X 的位置。</p>
<ol>
<li>
<p>第二个数表示当 k 元集合 P 代表 A 的位置且特征值为 S 时 X 的位置。</p>
</li>
<li>
<p>第三个数表示当 k 元集合 P 代表 B 的位置且特征值为 S 时 X 的位置。</p>
</li>
</ol>
<h2>输入输出样例</h2>
<h4>输入样例 #1</h4>
<p>5
3344
2</p>
<h4>输出样例 #1</h4>
<p>10
1
2</p>
<h4>输入样例 #2</h4>
<p>500000
4545
234567</p>
<h4>输出样例 #2</h4>
<p>999992
246922
753067</p>
<h2>说明</h2>
<p>【样例解释】</p>
<p>第一个样例中, P 数组为 1 的元素的下标分别为 5, 6, 7, 8, 9。</p>
<p>【数据范围与约定】</p>
<p>对于 30% 的数据，k ≤ 10^3。</p>
<p>对于 50% 的数据，k ≤ 10^5。</p>
<p>对于 100% 的数据，k ≤ 10^7。</p>
<p>对于每个测试点, 得分为以下三部分得分之和：</p>
<ol>
<li>
<p>如果第一问回答正确，你将获得 3 分。</p>
</li>
<li>
<p>如果第二问回答正确，你将获得 4 分。</p>
</li>
<li>
<p>如果第三问回答正确，你将获得 3 分。</p>
</li>
</ol>
<p><strong>如果你仅仅知道部分答案，请也务必按此格式要求输出三个数。否则你可能会因格式错误无法得分。</strong></p>