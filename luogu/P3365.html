<h1>改造二叉树</h1>
<h2>题目背景</h2>
<p>勤奋又善于思考的小L接触了信息学竞赛，开始的学习十分顺利。但是，小L对数据结构的掌握实在十分渣渣。</p>
<p>所以，小L当时卡在了二叉树。</p>
<h2>题目描述</h2>
<p>在计算机科学中，二叉树是每个结点最多有两个子结点的有序树。通常子结点被称作“左孩子”和“右孩子”。二叉树被用作二叉搜索树和二叉堆。随后他又和他人讨论起了二叉搜索树。什么是二叉搜索树呢？二叉搜索树首先是一棵二叉树。设key[p]表示结点p上的数值。对于其中的每个结点p，若其存在左孩子lch，则key[p]&gt;key[lch]；若其存在右孩子rch，则key[p]&lt;key[rch]；注意，本题中的二叉搜索树应满足对于所有结点，其左子树中的key小于当前结点的key，其右子树中的key大于当前结点的key。（因为小L十分喜欢装xx，所以这里他十分装xx的给大家介绍了什么是二叉树和二叉搜索树）。</p>
<p>可是善于思考的小L不甘于只学习这些基础的东西。他思考了这样一个问题：现在给定一棵二叉树，可以任意修改结点的数值。修改一个结点的数值算作一次修改，且这个结点不能再被修改。若要将其变成一棵二叉搜索树，且任意时刻结点的数值必须是整数（可以是负整数或0），所要的最少修改次数。</p>
<p>这一定难不倒聪明的你吧！如果你能帮小L解决这个问题，也许他会把最后的资产分给你1/16哦！</p>
<h2>输入输出格式</h2>
<h4>输入格式</h4>
<p>第一行一个正整数n表示二叉树节点数。</p>
<p>第二行n个正整数用空格分隔开，第i个数ai表示结点i的原始数值。</p>
<p>此后n - 1行每行两个非负整数fa, ch，第i + 2行描述结点i + 1的父亲编号fa，以及父子关系ch，(ch = 0 表示i + 1为左儿子，ch = 1表示i + 1为右儿子)。</p>
<p>为了让你稍微减轻些负担，小L规定：结点1一定是二叉树的根哦！</p>
<h4>输出格式</h4>
<p>仅一行包含一个整数，表示最少的修改次数</p>
<h2>输入输出样例</h2>
<h4>输入样例 #1</h4>
<p>3
2 2 2
1 0
1 1</p>
<h4>输出样例 #1</h4>
<p>2</p>
<h2>说明</h2>
<p>20 % ：n &lt;= 10 , ai &lt;= 100.</p>
<p>40 % ：n &lt;= 100 , ai &lt;= 200</p>
<p>60 % ：n &lt;= 2000 .</p>
<p>100 % ：n &lt;= 10 ^ 5 ,  ai &lt; 2 ^ 31. </p>