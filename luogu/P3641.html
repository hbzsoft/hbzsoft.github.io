<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
	    tex2jax: {
	        inlineMath: [['$','$'], ['\(','\)']],
	        processEscapes: true
	    }
	});
    </script>
</head><h1>[APIO2016] 最大差分</h1>
<h2>题目背景</h2>
<h2>评测方式</h2>
<p>以下是本题评测方式，与题面不符时以这里为准。</p>
<p>你的代码中不应该包含 <code>gap.h</code> 库。</p>
<p>你的代码中需如下进行 <code>findGap</code> 和 <code>MinMax</code> 函数的声明：
<code>cpp
extern "C" void MinMax(long long,long long,long long*,long long*);
extern "C" long long findGap(int,int);</code></p>
<p><a href="https://www.luogu.com.cn/paste/c4olee2x">spj 与交互库</a></p>
<p>不保证没锅，要是有锅请私信供题人然后 D 死他。</p>
<h2>题目描述</h2>
<p>有 $N$ 个严格递增的非负整数 $a_1, a_2, \dots, a_N$（$0 \leq a_1 &lt; a_2 &lt; \cdots &lt; a_N \leq 10^{18}$）。你需要找出 $a_{i + 1} - a_i$（$1 \leq i \leq N - 1$）里的最大的值。</p>
<p>你的程序不能直接读入这个整数序列，但是你可以通过给定的函数来查询该序列的信息。关于查询函数的细节，请根据你所使用的语言，参考下面的实现细节部分。</p>
<p>你需要实现一个函数,该函数返回 $a_{i + 1} - a_i$（$1 \leq i \leq N - 1$）中的最大值。</p>
<h2>实现细节</h2>
<p><strong>本题只支持 C++（包括 cpp11，cpp14，cpp17）</strong>。</p>
<h3>C/C++</h3>
<p>你需要包含头文件 <code>gap.h</code>。</p>
<p>你需要实现一个函数 <code>findGap(T, N)</code>，该函数接受下面的参数，并返回一个 <code>long long</code> 类型的整数：</p>
<ul>
<li>$T$：子任务的编号（$1$ 或者 $2$）</li>
<li>$N$：序列的长度</li>
</ul>
<p>你的函数 <code>findGap</code> 可以调用系统提供的查询函数 <code>MinMax(s, t, &amp;amp;mn, &amp;amp;mx)</code>，该函数的前两个参数 $s$ 和 $t$ 是 <code>long long</code> 类型的整数，后两个参数 <code>&amp;amp;mn</code> 和 <code>&amp;amp;mx</code> 是 <code>long long</code> 类型的整数的指针（<code>mn</code> 和 <code>mx</code> 是 <code>long long</code> 类型的整数）。当 <code>MinMax(s, t, &amp;amp;mn, &amp;amp;mx)</code> 返回时，变量 <code>mn</code> 将会存储满足 $a_i \in [s, t]$ 中 $a_i$ 的最小值，变量 <code>mx</code> 将会存储满足 $a_i \in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 <code>mn</code> 和 <code>mx</code> 都将存储 $-1$。在查询时需要满足 $s \leq t$，否则程序将会终止，该测试点计为 $0$ 分。</p>
<h3>Pascal</h3>
<p>你需要使用单元 <code>graderhelperlib</code>。</p>
<p>你需要实现一个函数 <code>findGap(T, N)</code>，该函数接受下面的参数，并返回一个 <code>Int64</code> 类型的整数：</p>
<ul>
<li>$T$：子任务的编号（$1$ 或者 $2$）（<code>Integer</code> 类型）</li>
<li>$N$：序列的长度（<code>LongInt</code> 类型）</li>
</ul>
<p>你的函数 <code>findGap</code> 可以调用系统提供的查询函数 <code>MinMax(s, t, mn, mx)</code>，该函数的前两个参数 $s$ 和 $t$ 是 <code>Int64</code> 类型的整数，后两个参数 <code>mn</code> 和 <code>mx</code> 是传引用方式的 <code>Int64</code> 类型的整数（过程内部对这两个变量的修改会影响到外部的对应变量的值）。当 <code>MinMax(s, t, mn, mx)</code> 执行完毕时，变量 <code>mn</code> 将会存储满足 $a_i \in [s, t]$ 中 $a_i$ 的最小值，变量 <code>mx</code> 将会存储满足 $a_i \in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 <code>mn</code> 和 <code>mx</code> 都将存储 $-1$。在查询时需要满足 $s \leq t$，否则程序将会终止，该测试点计为 $0$ 分。</p>
<h2>输入输出格式</h2>
<h4>输入格式</h4>
<h2>样例一</h2>
<h3>C/C++</h3>
<p>考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。</p>
<p>则答案应该是 $3$，可以通过下面的几组对 <code>MinMax</code> 的询问获得：</p>
<p>调用 <code>MinMax(1, 2, &amp;amp;mn, &amp;amp;mx)</code>，则 <code>mn</code> 和 <code>mx</code> 皆返回 $2$。</p>
<p>调用 <code>MinMax(3, 7, &amp;amp;mn, &amp;amp;mx)</code>，则 <code>mn</code> 返回 $3$，<code>mx</code> 返回 $6$。</p>
<p>调用 <code>MinMax(8, 9, &amp;amp;mn, &amp;amp;mx)</code>，则 <code>mn</code> 和 <code>mx</code> 皆返回 $8$。</p>
<h3>Pascal</h3>
<p>考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。</p>
<p>则答案应该是 $3$，可以通过下面的几组对 <code>MinMax</code> 的询问获得：</p>
<p>调用 <code>MinMax(1, 2, mn, mx)</code>，则 <code>mn</code> 和 <code>mx</code> 皆返回 $2$。</p>
<p>调用 <code>MinMax(3, 7, mn, mx)</code>，则 <code>mn</code> 返回 $3$，<code>mx</code> 返回 $6$。</p>
<p>调用 <code>MinMax(8, 9, mn, mx)</code>，则 <code>mn</code> 和 <code>mx</code> 皆返回 $8$。</p>
<h2>样例评测方式</h2>
<p>样例测评系统从标准输入中读入两行。第一行包含两个整数，子任务编号 $T$，和序列长度 $N$。第二行包含 $N$ 个严格递增的非负整数。然后该程序会向标准输出中写入两行，第一行为 <code>findGap</code> 的返回值，第二行为花费 $M$ 的值。</p>
<p>下面的输入描述了上面的样例：</p>
<p><code>plane
2 4
2 3 6 8</code>
注意实际使用的交互库和 spj 对数据进行了加密。</p>
<h4>输出格式</h4>
<h2>输入输出样例</h2>
<p>暂无测试点</p>
<h2>说明</h2>
<h2>限制与约定</h2>
<p>对于所有的测试点，有 $2 \leq N \leq 100000$。</p>
<p>每一个测试点开始测试之前，$M$ 都将被初始化为 $0$。</p>
<p>子任务 1（$30$ 分）：每一次调用 <code>MinMax</code> 都将使 $M$ 加 $1$。为了获得所有分数，需要满足对于该子任务下的所有测试点，都有 $M \leq \frac{N + 1}{2}$。</p>
<p>子任务 2（$70$ 分）：定义 $k$ 为调用 <code>MinMax</code> 时，区间 $[s, t]$ 中的序列中数的数量。每次调用 <code>MinMax</code>，将使 $M$ 加上 $k + 1$。对于每一个测试点，如果 $M \leq 3N$，你将得到 70 分，否则将得到 $\dfrac{60}{\sqrt{\frac MN + 1} - 1}$ 分。你的该子任务的得分是其下所有测试点中的最低分。</p>