# 题解：P13427 [COCI 2020/2021 #2] Odasiljaci
2025-07-23

## 题意分析
在一个二维坐标系内，有 $n$ 个点，给出了它们的坐标。需要求出一个最小的覆盖半径 $r$，使得各个点能够连接在一起。
## 解法分析
我们可以将整个坐标系抽象为一张图，每一个点是图上的节点，对于任意两个点，建立一条边，边权为它们之间的几何距离。\
为了形成连通块，我们需要求出最小生成树，即让**最大的边权尽可能地小**。因此，我们应当使用 Kruskal 算法，在这张图上求出最小生成树。答案即为最小生成树中**边权最大的边的一半**。
## 代码实现
实现比较简单，细节不多。请看代码。
```cpp
#include <bits/stdc++.h>

#define int long long
using namespace std;
const int N=1005;
int x[N],y[N],fa[N];
struct edge
{
    int a,b;
    long double dst;
}
;
vector<edge> graph;
int n;

bool cmp(edge a,edge b) {
    return a.dst<b.dst;
}
// 并查集
int find(int x) {
    return ((fa[x]==x)?(x):(fa[x]=find(fa[x])));
}

void merge(int x,int y) {
    fa[find(x)]=find(y);
}

//kruskal算法（核心）
void kruskal() {
    long double ans=0;
    int cnt=0;

    for(auto i:graph) {

        if(find(i.a)!=find(i.b)) {
            merge(i.a,i.b);
            ans=max(ans,i.dst);
            cnt++;
        }
        if(cnt==n-1) break;
    }
    cout<<fixed<<setprecision(10)<<ans/2<<endl;
}

signed main() {
    cin>>n;

    for(int i=1;i<=n;i++) {
        cin>>x[i]>>y[i];
    }

    for(int i=1;i<=n;i++) {
        fa[i]=i;

        for(int j=i+1;j<=n;j++) {
            // 计算几何距离
            long long d=(x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]);
            long double dst=sqrt(d);
            // 建边
            graph.push_back( {
                i,j,dst
            }
            );
        }
    }
    // 边权排序
    sort(graph.begin(),graph.end(),cmp);
    // 跑一边kruskal
    kruskal();
}
```
